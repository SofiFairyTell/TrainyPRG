Это будет файл со всяким справочным материалом. Считается признаком хорошего тона. 

0. В настройках проектах необходимо в первую очередь установить многобайтовую кодировку.
Тогда можно избежать проблем с битой кодировкой при отправке на удаленный репозиторий. 
Делается это через свойства проекта ( У нас проект это lab1  и т.д. TrainyPRG это решение - sln, 
в котором может быть много проектов)

Конфигурация - Все конфигурации
Далее: Свойства конфигурации - Дополнительно. 
В табличке искать - Расширенные свойства - набор символов. 
Далее - установить многобайтовую кодировку. 

Подобное можно делать и не для *Все кофигурации*. А например для каждой версии разные. Debug например на Unicode, 
а Release на Многобайтовой. 

Но для лабораторных задач хватит и таких настроек. 

0.1. Сразу определимся, что выносить обработку чего-либо будем в отдельные функции. В main только их вызов
и вывод на экран результата. Это точнка входа основная, поэтому желательно, чтобы ничего лишнего в ней не было. 

1.В блоке include выполняется подключение заголовочных файлов. По сути это файлы где содержжаться функции. 
И чтобы их вызвать нужно обязательно подсоединить этот файл к проекту


Примечание1:
Особенность C++  в том, чтобы работать с потоками. Поэтому: 
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); говорит потоку ввода std::cin игнорировать 
все символы до символа новой строки ('\n') или до тех пор, пока не будет достигнуто максимальное количество символов, 
которое может обработать тип std::streamsize. Это полезно для очистки оставшихся символов во входном буфере после 
неудачной попытки чтения числа, чтобы избежать некорректного ввода при последующих попытках считывания.

std::numeric_limits<std::streamsize>::max() - это способ получить максимальное значение для типа streamsize которй представляет собой
тип, используемый для представления размеров буфера потока. А numeric_limits - это шаблон класса который предоставляет информацию о 
числовых типах, включая из минимальное и максимальное значение

Можно написат проверку без использования std::cin.clear() и std::cin.ignore(), но в этом случае, если пользователь введет
некорректные данные, символы, которые вызвали ошибку, останутся во входном буфере, и это может привести к некорректным 
результатам при следующем чтении.